#!/usr/bin/python
#
# 'pisa' encoder
#

import sys,random

#
# parameters
#
kFibCount = 14
NL = 0x0A
PayloadLength = 256 # must be multiple of 8. 'pisa' wants 256.

#
# functions
#

# Generate a Fibonacci sequence, starting at [0,1]
def FibonacciSequence(count):
  fibo = [0,1]
  for i in range(len(fibo),count):
    fibo.append(fibo[i-2]+fibo[i-1])
  return fibo

# Calculate the value associated with a fibonacci sequence pattern.
# We interpret the pattern integer so that the MSB maps to 0, 
# LSB maps to the highest value in the fib sequence.
def FibVal(pat):
  val = 0
  for i in range(1,kFibCount):
    if (pat & 1<<(kFibCount-i-1)) != 0:
      val += FibSeq[i]
  val &= 255
  return val

# Convert integer to string of chars 0 and 1
def bstr(n,l):
  return '' if (l==0) else (bstr(n>>1, l-1) + ( "1" if n&1 else "0"))

####

# Pattern precalculation.

# The values of our Fibonacci sequence.
FibSeq = FibonacciSequence(kFibCount)

# Determine all possible encodings for each byte value.
FibEnc = dict([ (val,[]) for val in range(0,256) ])
for pat in range(0,pow(2,kFibCount)):
  val = FibVal(pat)
  FibEnc[val].append(pat)

# Then, filter the safe values for each of four relative positions.

# In position A, the fib encoding is split as 3-8-3 bits.
def FilterA(value, encoding):
  if ((encoding>>11) & 0x07) == (NL & 0x07): return False
  if ((encoding>>3) & 0xFF) == (NL & 0xFF): return False
  if ((encoding<<5) & 0xE0) == (NL & 0xE0): return False
  return True
  #sys.exit("INTERNAL ERROR - No safe encoding found for %d in position A." % (value,))

# In position B, the fib encoding is split as 5-8-1 bits.
def FilterB(value, encoding):
  if ((encoding>>9) & 0x1F) == (NL & 0x1F): return False
  if ((encoding>>1) & 0xFF) == (NL & 0xFF): return False
  if ((encoding<<7) & 0x80) == (NL & 0x80): return False
  return True
  #sys.exit("INTERNAL ERROR - No safe encoding found for %d in position B." % (value,))

# In position C, the fib encoding is split as 7-7 bits.
def FilterC(value, encoding):
  if ((encoding>>7) & 0x7F) == (NL & 0x7F): return False
  if ((encoding<<1) & 0xFE) == (NL & 0xFE): return False
  return True
  #sys.exit("INTERNAL ERROR - No safe encoding found for %d in position C." % (value,))

# In position D, the fib encoding is split as 1-8-5 bits.
def FilterD(value, encoding):
  if ((encoding>>13) & 0x01) == (NL & 0x01): return False
  if ((encoding>>5) & 0xFF) == (NL & 0xFF): return False
  if ((encoding<<3) & 0xF8) == (NL & 0xF8): return False
  return True
  #sys.exit("INTERNAL ERROR - No safe encoding found for %d in position D." % (value,))

FibEncodeA = dict([ (v, [ e for e in es if FilterA(v, e) ]) for (v,es) in FibEnc.iteritems() ])
FibEncodeB = dict([ (v, [ e for e in es if FilterB(v, e) ]) for (v,es) in FibEnc.iteritems() ])
FibEncodeC = dict([ (v, [ e for e in es if FilterC(v, e) ]) for (v,es) in FibEnc.iteritems() ])
FibEncodeD = dict([ (v, [ e for e in es if FilterD(v, e) ]) for (v,es) in FibEnc.iteritems() ])

def PickRandom(l):
  return l[random.randrange(len(l))]

# Generate the output

def pisa_encode(data):

  # Make sure data has correct size. 
  if len(data) > PayloadLength:
    print >>sys.stderr, "WARNING: data is longer than allowed size of",PayloadLength
    data = data[:PayloadLength-1] + '\0'
  if len(data) < PayloadLength:
    data += chr(0)
  while len(data) < PayloadLength:
    data += chr(random.randrange(256))

  # Generate a header that has an odd total length.
  # Filter patterns used elsewhere are specific for our choice of 2.
  header_length = 2 # plus 3 for the length field
  header_data = 0
  bits = bstr(header_length, 3)
  bits += bstr(header_data, header_length)

  # Now encode the payload data.
  # Based on the header block length of 5, we determined safe encodings.
  for i in range(0,PayloadLength,8):
    bits += bstr(PickRandom(FibEncodeA[ord(data[i+0])]), 14)
    bits += bstr(ord(data[i+1]), 8)
    bits += bstr(PickRandom(FibEncodeB[ord(data[i+2])]), 14)
    bits += bstr(ord(data[i+3]), 8)
    bits += bstr(PickRandom(FibEncodeC[ord(data[i+4])]), 14)
    bits += bstr(ord(data[i+5]), 8)
    bits += bstr(PickRandom(FibEncodeD[ord(data[i+6])]), 14)
    bits += bstr(ord(data[i+7]), 8)

  # Pad to multiple of 8 bits.
  bits += "0" * ~( ~(len(bits)-1) & 7 )
  # Split on byte boundaries.
  bits_by_byte = [ bits[p:p+8] for p in range(0,len(bits),8) ]

  # Double-check that no newline occurs.
  NL_bits = bstr(NL,8)
  if bits_by_byte.count(NL_bits) != 0:
    sys.exit("INTERNAL ERROR: newline occurs in encoded output.")

  return ''.join([ chr( int(s,2) ) for s in bits_by_byte ])

def main():
  indata = sys.stdin.read()
  encoded = pisa_encode(indata)
  sys.stdout.write(encoded)
  sys.stdout.write(chr(NL))

main()

